{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _taggedTemplateLiteral from \"@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject() {\n  var data = _taggedTemplateLiteral([\"\\n  mutation RefreshToken($token: String!) {\\n    refreshToken(token: $token) {\\n      accessToken\\n      refreshToken\\n    }\\n  }\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { fromPromise, gql } from '@apollo/client';\nimport { onError } from '@apollo/client/link/error';\nimport { config } from '~src/config';\nimport { createApolloClient } from './apollo-client';\nexport var ErrorLink = onError(_c = function _c(_ref) {\n  var graphQLErrors = _ref.graphQLErrors,\n      operation = _ref.operation,\n      forward = _ref.forward;\n\n  if (!graphQLErrors || !graphQLErrors.length) {\n    return;\n  }\n\n  var _iterator = _createForOfIteratorHelper(graphQLErrors),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var gqlError = _step.value;\n\n      if (!isUnauthorizedError(gqlError) || isRefreshTokenOperation(operation)) {\n        return;\n      }\n\n      return fromPromise(getNewTokens()[\"catch\"](function (err) {\n        localStorage.removeItem(config.ACCESS_TOKEN_KEY);\n        localStorage.removeItem(config.REFRESH_TOKEN_KEY);\n        throw err;\n      })).flatMap(function (accessToken) {\n        // modify the operation context with a new token\n        operation.setContext({\n          headers: {\n            authorization: \"Bearer \".concat(accessToken)\n          }\n        }); // retry the request, returning the new observable\n\n        return forward(operation);\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return;\n});\n_c2 = ErrorLink;\n\nfunction isUnauthorizedError(error) {\n  return error && error.message === 'Unauthorized';\n}\n\nfunction isRefreshTokenOperation(operation) {\n  return operation && operation.operationName === 'RefreshToken';\n}\n\nvar REFRESH_TOKEN_MUTATION = gql(_templateObject());\n\nfunction getNewTokens() {\n  return _getNewTokens.apply(this, arguments);\n}\n\nfunction _getNewTokens() {\n  _getNewTokens = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var existingRefreshToken, client, _yield$client$mutate, data, _data$refreshToken, accessToken, refreshToken;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            existingRefreshToken = localStorage.getItem(config.REFRESH_TOKEN_KEY);\n\n            if (existingRefreshToken) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 3:\n            client = createApolloClient();\n            _context.next = 6;\n            return client.mutate({\n              mutation: REFRESH_TOKEN_MUTATION,\n              variables: {\n                token: existingRefreshToken\n              },\n              errorPolicy: 'none'\n            });\n\n          case 6:\n            _yield$client$mutate = _context.sent;\n            data = _yield$client$mutate.data;\n\n            if (data) {\n              _context.next = 10;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 10:\n            _data$refreshToken = data.refreshToken, accessToken = _data$refreshToken.accessToken, refreshToken = _data$refreshToken.refreshToken;\n            localStorage.setItem(config.ACCESS_TOKEN_KEY, accessToken);\n            localStorage.setItem(config.REFRESH_TOKEN_KEY, refreshToken);\n            return _context.abrupt(\"return\", accessToken);\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getNewTokens.apply(this, arguments);\n}\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ErrorLink$onError\");\n$RefreshReg$(_c2, \"ErrorLink\");","map":{"version":3,"sources":["/home/luca/code/lucapasquale/linking-bio/packages/frontend/src/helpers/graphql/error-link.ts"],"names":["fromPromise","gql","onError","config","createApolloClient","ErrorLink","graphQLErrors","operation","forward","length","gqlError","isUnauthorizedError","isRefreshTokenOperation","getNewTokens","err","localStorage","removeItem","ACCESS_TOKEN_KEY","REFRESH_TOKEN_KEY","flatMap","accessToken","setContext","headers","authorization","error","message","operationName","REFRESH_TOKEN_MUTATION","existingRefreshToken","getItem","client","mutate","mutation","variables","token","errorPolicy","data","refreshToken","setItem"],"mappings":";;;;;;;;;;;;;;;;;;;;AACA,SAASA,WAAT,EAAsBC,GAAtB,QAA4C,gBAA5C;AACA,SAASC,OAAT,QAAwB,2BAAxB;AAEA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,kBAAT,QAAmC,iBAAnC;AAEA,OAAO,IAAMC,SAAS,GAAGH,OAAO,MAAC,kBAA2C;AAAA,MAAxCI,aAAwC,QAAxCA,aAAwC;AAAA,MAAzBC,SAAyB,QAAzBA,SAAyB;AAAA,MAAdC,OAAc,QAAdA,OAAc;;AAC1E,MAAI,CAACF,aAAD,IAAkB,CAACA,aAAa,CAACG,MAArC,EAA6C;AAC3C;AACD;;AAHyE,6CAKnDH,aALmD;AAAA;;AAAA;AAK1E,wDAAsC;AAAA,UAA3BI,QAA2B;;AACpC,UAAI,CAACC,mBAAmB,CAACD,QAAD,CAApB,IAAkCE,uBAAuB,CAACL,SAAD,CAA7D,EAA0E;AACxE;AACD;;AAED,aAAOP,WAAW,CAChBa,YAAY,WAAZ,CAAqB,UAACC,GAAD,EAAS;AAC5BC,QAAAA,YAAY,CAACC,UAAb,CAAwBb,MAAM,CAACc,gBAA/B;AACAF,QAAAA,YAAY,CAACC,UAAb,CAAwBb,MAAM,CAACe,iBAA/B;AAEA,cAAMJ,GAAN;AACD,OALD,CADgB,CAAX,CAOLK,OAPK,CAOG,UAACC,WAAD,EAAiB;AACzB;AACAb,QAAAA,SAAS,CAACc,UAAV,CAAqB;AACnBC,UAAAA,OAAO,EAAE;AAAEC,YAAAA,aAAa,mBAAYH,WAAZ;AAAf;AADU,SAArB,EAFyB,CAMzB;;AACA,eAAOZ,OAAO,CAACD,SAAD,CAAd;AACD,OAfM,CAAP;AAgBD;AA1ByE;AAAA;AAAA;AAAA;AAAA;;AA4B1E;AACD,CA7B+B,CAAzB;MAAMF,S;;AA+Bb,SAASM,mBAAT,CAA6Ba,KAA7B,EAAkD;AAChD,SAAOA,KAAK,IAAIA,KAAK,CAACC,OAAN,KAAkB,cAAlC;AACD;;AAED,SAASb,uBAAT,CAAiCL,SAAjC,EAAuD;AACrD,SAAOA,SAAS,IAAIA,SAAS,CAACmB,aAAV,KAA4B,cAAhD;AACD;;AAED,IAAMC,sBAAsB,GAAG1B,GAAH,mBAA5B;;SASeY,Y;;;;;2EAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AACQe,YAAAA,oBADR,GAC+Bb,YAAY,CAACc,OAAb,CAAqB1B,MAAM,CAACe,iBAA5B,CAD/B;;AAAA,gBAEOU,oBAFP;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAMQE,YAAAA,MANR,GAMiB1B,kBAAkB,EANnC;AAAA;AAAA,mBAOyB0B,MAAM,CAACC,MAAP,CAAc;AACnCC,cAAAA,QAAQ,EAAEL,sBADyB;AAEnCM,cAAAA,SAAS,EAAE;AAAEC,gBAAAA,KAAK,EAAEN;AAAT,eAFwB;AAGnCO,cAAAA,WAAW,EAAE;AAHsB,aAAd,CAPzB;;AAAA;AAAA;AAOUC,YAAAA,IAPV,wBAOUA,IAPV;;AAAA,gBAaOA,IAbP;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA,iCAiBwCA,IAAI,CAACC,YAjB7C,EAiBUjB,WAjBV,sBAiBUA,WAjBV,EAiBuBiB,YAjBvB,sBAiBuBA,YAjBvB;AAkBEtB,YAAAA,YAAY,CAACuB,OAAb,CAAqBnC,MAAM,CAACc,gBAA5B,EAA8CG,WAA9C;AACAL,YAAAA,YAAY,CAACuB,OAAb,CAAqBnC,MAAM,CAACe,iBAA5B,EAA+CmB,YAA/C;AAnBF,6CAqBSjB,WArBT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import { GraphQLError } from 'graphql'\nimport { fromPromise, gql, Operation } from '@apollo/client'\nimport { onError } from '@apollo/client/link/error'\n\nimport { config } from '~src/config'\nimport { createApolloClient } from './apollo-client'\n\nexport const ErrorLink = onError(({ graphQLErrors, operation, forward }) => {\n  if (!graphQLErrors || !graphQLErrors.length) {\n    return\n  }\n\n  for (const gqlError of graphQLErrors) {\n    if (!isUnauthorizedError(gqlError) || isRefreshTokenOperation(operation)) {\n      return\n    }\n\n    return fromPromise(\n      getNewTokens().catch((err) => {\n        localStorage.removeItem(config.ACCESS_TOKEN_KEY)\n        localStorage.removeItem(config.REFRESH_TOKEN_KEY)\n\n        throw err\n      })\n    ).flatMap((accessToken) => {\n      // modify the operation context with a new token\n      operation.setContext({\n        headers: { authorization: `Bearer ${accessToken}` },\n      })\n\n      // retry the request, returning the new observable\n      return forward(operation)\n    })\n  }\n\n  return\n})\n\nfunction isUnauthorizedError(error: GraphQLError) {\n  return error && error.message === 'Unauthorized'\n}\n\nfunction isRefreshTokenOperation(operation: Operation) {\n  return operation && operation.operationName === 'RefreshToken'\n}\n\nconst REFRESH_TOKEN_MUTATION = gql`\n  mutation RefreshToken($token: String!) {\n    refreshToken(token: $token) {\n      accessToken\n      refreshToken\n    }\n  }\n`\n\nasync function getNewTokens() {\n  const existingRefreshToken = localStorage.getItem(config.REFRESH_TOKEN_KEY)\n  if (!existingRefreshToken) {\n    return\n  }\n\n  const client = createApolloClient()\n  const { data } = await client.mutate({\n    mutation: REFRESH_TOKEN_MUTATION,\n    variables: { token: existingRefreshToken },\n    errorPolicy: 'none',\n  })\n\n  if (!data) {\n    return\n  }\n\n  const { accessToken, refreshToken } = data.refreshToken\n  localStorage.setItem(config.ACCESS_TOKEN_KEY, accessToken)\n  localStorage.setItem(config.REFRESH_TOKEN_KEY, refreshToken)\n\n  return accessToken\n}\n"]},"metadata":{},"sourceType":"module"}